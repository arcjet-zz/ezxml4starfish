"""
XML生成服务
将JSON结构生成为Starfish XML文件
"""

from typing import Dict, List, Any
import xml.etree.ElementTree as ET
from xml.dom import minidom
import logging

from app.models.simulation import SimulationProject, Boundary, Material, Source, Interaction

logger = logging.getLogger(__name__)

class XMLGeneratorService:
    """XML生成服务类"""

    def generate_xml_files(self, project: SimulationProject) -> Dict[str, str]:
        """
        生成所有XML文件

        Args:
            project: 项目对象

        Returns:
            Dict[str, str]: 文件名到XML内容的映射
        """
        logger.info("Starting XML file generation")

        # 验证和修复材料引用
        self._validate_and_fix_material_references(project)

        # 处理电离能：从MCC相互作用中提取并添加到材料定义中
        self._process_ionization_energies(project)

        xml_files = {}

        # 生成计算域文件
        xml_files["domain.xml"] = self._generate_domain_xml(project)
        logger.info("Generated domain.xml")

        # 生成边界文件（在处理源项后，可能会创建默认边界）
        # 先处理源项，这可能会创建默认边界
        sources_xml = None
        if project.sources:
            sources_xml = self._generate_sources_xml(project.sources, project)

        # 现在生成边界文件（如果有边界的话）
        if project.boundaries:
            xml_files["boundaries.xml"] = self._generate_boundaries_xml(project.boundaries, project)
            logger.info("Generated boundaries.xml")

        # 生成材料文件
        if project.materials:
            xml_files["materials.xml"] = self._generate_materials_xml(project.materials)
            logger.info("Generated materials.xml")

        # 生成源文件（如果之前没有生成的话）
        if project.sources and sources_xml is None:
            sources_xml = self._generate_sources_xml(project.sources, project)

        if sources_xml:
            xml_files["sources.xml"] = sources_xml
            logger.info("Generated sources.xml")

        # 生成相互作用文件
        if project.interactions:
            xml_files["interactions.xml"] = self._generate_interactions_xml(project.interactions)
            logger.info("Generated interactions.xml")

        # 最后生成主配置文件（这样可以正确检查所有文件是否存在）
        xml_files["starfish.xml"] = self._generate_starfish_xml(project, xml_files)
        logger.info("Generated starfish.xml")

        logger.info(f"Generated {len(xml_files)} XML files")
        return xml_files
    
    def _generate_starfish_xml(self, project: SimulationProject, xml_files: Dict[str, str] = None) -> str:
        """生成主配置文件"""
        root = ET.Element("simulation")

        # 添加注释
        note = ET.SubElement(root, "note")
        note.text = "Generated by Starfish-ezxml"

        # 添加日志配置
        log = ET.SubElement(root, "log")
        log.set("level", "Log")

        # 添加加载指令 - 按照示例文件的顺序，基于实际生成的文件
        load_domain = ET.SubElement(root, "load")
        load_domain.text = "domain.xml"

        if xml_files and "materials.xml" in xml_files:
            load_materials = ET.SubElement(root, "load")
            load_materials.text = "materials.xml"

        if xml_files and "boundaries.xml" in xml_files:
            load_boundaries = ET.SubElement(root, "load")
            load_boundaries.text = "boundaries.xml"

        if xml_files and "interactions.xml" in xml_files:
            load_interactions = ET.SubElement(root, "load")
            load_interactions.text = "interactions.xml"

        if xml_files and "sources.xml" in xml_files:
            load_sources = ET.SubElement(root, "load")
            load_sources.text = "sources.xml"

        # 添加求解器配置 - 符合Starfish XML规范
        if project.settings.solver_type != "none":
            solver = ET.SubElement(root, "solver")
            solver.set("type", project.settings.solver_type)  # 直接使用Starfish类型

            # 泊松求解器参数
            if project.settings.solver_type == "poisson":
                if project.settings.method:
                    method = ET.SubElement(solver, "method")
                    method.text = project.settings.method

                if project.settings.n0 is not None:
                    n0 = ET.SubElement(solver, "n0")
                    n0.text = str(project.settings.n0)

                if project.settings.Te0 is not None:
                    te0 = ET.SubElement(solver, "Te0")
                    te0.text = str(project.settings.Te0)

                if project.settings.phi0 is not None:
                    phi0 = ET.SubElement(solver, "phi0")
                    phi0.text = str(project.settings.phi0)

                if project.settings.max_it is not None:
                    max_it = ET.SubElement(solver, "max_it")
                    max_it.text = str(project.settings.max_it)

                if project.settings.nl_max_it is not None:
                    nl_max_it = ET.SubElement(solver, "nl_max_it")
                    nl_max_it.text = str(project.settings.nl_max_it)

                if project.settings.tol is not None:
                    tol = ET.SubElement(solver, "tol")
                    tol.text = str(project.settings.tol)

                if project.settings.nl_tol is not None:
                    nl_tol = ET.SubElement(solver, "nl_tol")
                    nl_tol.text = str(project.settings.nl_tol)

                if project.settings.tolerance is not None:
                    tolerance = ET.SubElement(solver, "tolerance")
                    tolerance.text = str(project.settings.tolerance)

                if project.settings.linear is not None:
                    linear = ET.SubElement(solver, "linear")
                    linear.text = str(project.settings.linear).lower()

                if project.settings.initial_only is not None:
                    initial_only = ET.SubElement(solver, "initial_only")
                    initial_only.text = str(project.settings.initial_only).lower()

            # 常电场求解器参数
            elif project.settings.solver_type == "constant-ef":
                if project.settings.comps:
                    comps = ET.SubElement(solver, "comps")
                    comps.text = project.settings.comps

        # 添加时间配置
        time = ET.SubElement(root, "time")
        num_it = ET.SubElement(time, "num_it")
        num_it.text = str(project.settings.iterations)
        dt = ET.SubElement(time, "dt")
        dt.text = str(project.settings.time_step)

        if project.settings.steady_state is not None:
            steady_state = ET.SubElement(time, "steady_state")
            steady_state.text = str(project.settings.steady_state)

        # 添加平均化配置
        if (project.settings.averaging_frequency is not None or
            project.settings.averaging_start_it is not None or
            project.settings.averaging_variables is not None):
            averaging = ET.SubElement(root, "averaging")
            if project.settings.averaging_frequency is not None:
                averaging.set("frequency", str(project.settings.averaging_frequency))
            if project.settings.averaging_start_it is not None:
                averaging.set("start_it", str(project.settings.averaging_start_it))
            if project.settings.averaging_variables:
                variables = ET.SubElement(averaging, "variables")
                variables.text = project.settings.averaging_variables

        # 添加动画配置
        if (project.settings.animation_start_it is not None or
            project.settings.animation_frequency is not None):
            animation = ET.SubElement(root, "animation")
            if project.settings.animation_start_it is not None:
                animation.set("start_it", str(project.settings.animation_start_it))
            if project.settings.animation_frequency is not None:
                animation.set("frequency", str(project.settings.animation_frequency))

        # 添加重启配置
        if project.settings.restart is not None:
            restart = ET.SubElement(root, "restart")
            if project.settings.restart.it_save is not None:
                it_save = ET.SubElement(restart, "it_save")
                it_save.text = str(project.settings.restart.it_save)
            if project.settings.restart.save is not None:
                save = ET.SubElement(restart, "save")
                save.text = str(project.settings.restart.save).lower()
            if project.settings.restart.load is not None:
                load_elem = ET.SubElement(restart, "load")
                load_elem.text = str(project.settings.restart.load).lower()
            if project.settings.restart.nt_add is not None:
                nt_add = ET.SubElement(restart, "nt_add")
                nt_add.text = str(project.settings.restart.nt_add)

        # 添加运行指令
        starfish = ET.SubElement(root, "starfish")

        if project.settings.randomize is not None:
            starfish.set("randomize", str(project.settings.randomize).lower())

        if project.settings.max_cores is not None:
            starfish.set("max_processors", str(project.settings.max_cores))

        # 添加输出配置
        for output in project.settings.outputs:
            output_elem = ET.SubElement(root, "output")
            output_elem.set("type", output.type)
            output_elem.set("file_name", output.file_name)
            output_elem.set("format", output.format)

            if output.variables:
                variables = ET.SubElement(output_elem, "variables")
                variables.text = output.variables
            if output.scalars:
                scalars = ET.SubElement(output_elem, "scalars")
                scalars.text = output.scalars
            if output.vectors:
                vectors = ET.SubElement(output_elem, "vectors")
                vectors.text = output.vectors

        return self._prettify_xml(root)

    def _generate_domain_xml(self, project: SimulationProject) -> str:
        """生成计算域文件"""
        root = ET.Element("domain")
        root.set("type", project.domain.type)

        # 添加网格配置
        mesh = ET.SubElement(root, "mesh")
        mesh.set("type", project.domain.mesh_type)
        mesh.set("name", project.domain.mesh_name)

        # 添加原点 - 智能格式化（科学计数法或普通格式）
        origin = ET.SubElement(mesh, "origin")
        origin_values = []
        for val in project.domain.origin:
            if val == int(val):
                origin_values.append(str(int(val)))
            elif abs(val) < 0.001 and val != 0:
                # 使用科学计数法，去掉+号和多余的0
                sci_text = f"{val:.0e}".replace("e+", "e").replace("e-0", "e-")
                origin_values.append(sci_text)
            else:
                origin_values.append(str(val))
        origin.text = ",".join(origin_values)

        # 添加间距 - 智能格式化（科学计数法或普通格式）
        spacing = ET.SubElement(mesh, "spacing")
        spacing_values = []
        for val in project.domain.spacing:
            if val == int(val):
                spacing_values.append(str(int(val)))
            elif abs(val) < 0.001 and val != 0:
                # 使用科学计数法，去掉+号和多余的0
                sci_text = f"{val:.1e}".replace("e+", "e").replace("e-0", "e-")
                spacing_values.append(sci_text)
            else:
                spacing_values.append(str(val))
        spacing.text = ", ".join(spacing_values)

        # 添加节点数 - 添加空格分隔
        nodes = ET.SubElement(mesh, "nodes")
        nodes.text = ", ".join(map(str, project.domain.nodes))

        # 添加网格边界条件
        for mesh_bc in project.domain.mesh_bcs:
            mesh_bc_elem = ET.SubElement(mesh, "mesh-bc")
            mesh_bc_elem.set("wall", mesh_bc.wall)
            mesh_bc_elem.set("type", mesh_bc.type)
            if mesh_bc.value:
                mesh_bc_elem.set("value", mesh_bc.value)

        return self._prettify_xml(root)
    
    def _generate_boundaries_xml(self, boundaries: List[Boundary], project: SimulationProject = None) -> str:
        """生成边界文件"""
        root = ET.Element("boundaries")

        # 添加transform元素（如果有）
        if project and project.domain.boundary_transform:
            transform = ET.SubElement(root, "transform")
            if project.domain.boundary_transform.scaling:
                scaling = ET.SubElement(transform, "scaling")
                scaling.text = project.domain.boundary_transform.scaling
            if project.domain.boundary_transform.translation:
                translation = ET.SubElement(transform, "translation")
                translation.text = project.domain.boundary_transform.translation
            if project.domain.boundary_transform.reverse is not None:
                reverse = ET.SubElement(transform, "reverse")
                reverse.text = str(project.domain.boundary_transform.reverse).lower()

        for boundary in boundaries:
            boundary_elem = ET.SubElement(root, "boundary")
            boundary_elem.set("name", boundary.name)
            boundary_elem.set("type", boundary.type)  # 直接使用Starfish类型

            # 添加value属性（优先使用value，然后是potential）
            value_attr = None
            if boundary.value is not None:
                value_attr = str(boundary.value)
            elif boundary.potential is not None:
                value_attr = str(boundary.potential)

            if value_attr is not None:
                boundary_elem.set("value", value_attr)

            # 添加reverse属性
            if boundary.reverse is not None:
                boundary_elem.set("reverse", str(boundary.reverse).lower())

            # 添加材料
            if boundary.material:
                material_elem = ET.SubElement(boundary_elem, "material")
                material_elem.text = boundary.material

            # 添加路径 - path是必需的
            path_elem = ET.SubElement(boundary_elem, "path")
            path_value = boundary.path if boundary.path else self._get_default_boundary_path(boundary)
            path_elem.text = path_value

            # 添加温度（优先使用temp，然后是temperature）
            temp_value = boundary.temp or boundary.temperature
            if temp_value is not None:
                temp_elem = ET.SubElement(boundary_elem, "temp")
                if temp_value == int(temp_value):
                    temp_elem.text = str(int(temp_value))
                else:
                    temp_elem.text = str(temp_value)

            # 添加节点
            if boundary.nodes:
                nodes_elem = ET.SubElement(boundary_elem, "nodes")
                for node in boundary.nodes:
                    node_elem = ET.SubElement(nodes_elem, "node")
                    node_elem.set("x", str(node.x))
                    node_elem.set("y", str(node.y))

        return self._prettify_xml(root)

    def _generate_materials_xml(self, materials: List[Material]) -> str:
        """生成材料文件 - 符合Starfish XML规范"""
        root = ET.Element("materials")

        for material in materials:
            material_elem = ET.SubElement(root, "material")
            material_elem.set("name", material.name)
            material_elem.set("type", material.type)  # 直接使用Starfish类型

            # 根据材料类型添加相应属性
            if material.type == "kinetic":
                # 动力学材料必需属性
                # molwt是必需的
                molwt = ET.SubElement(material_elem, "molwt")
                molwt_value = material.molwt if material.molwt is not None else self._get_default_molwt(material.type, material.name)
                if molwt_value == int(molwt_value):
                    molwt.text = str(int(molwt_value))
                else:
                    molwt.text = str(molwt_value)

                # charge是必需的
                charge = ET.SubElement(material_elem, "charge")
                charge.text = str(int(material.charge))

                # spwt是必需的
                spwt = ET.SubElement(material_elem, "spwt")
                spwt_value = material.spwt if material.spwt is not None else 1e11
                spwt_text = f"{spwt_value:.0e}".replace("e+0", "e").replace("e+", "e")
                spwt.text = spwt_text

                # 可选属性
                if material.init:
                    init = ET.SubElement(material_elem, "init")
                    init.text = material.init

                if material.ref_temp is not None:
                    ref_temp = ET.SubElement(material_elem, "ref_temp")
                    ref_temp.text = str(int(material.ref_temp) if material.ref_temp == int(material.ref_temp) else material.ref_temp)

                if material.visc_temp_index is not None:
                    visc_temp_index = ET.SubElement(material_elem, "visc_temp_index")
                    visc_temp_index.text = str(material.visc_temp_index)

                if material.vss_alpha is not None:
                    vss_alpha = ET.SubElement(material_elem, "vss_alpha")
                    vss_alpha.text = str(material.vss_alpha)

                if material.diam is not None:
                    diam = ET.SubElement(material_elem, "diam")
                    diam.text = f"{material.diam:.2e}"

                # 添加电离能（如果存在）
                if material.ionization_energy is not None:
                    ionization_energy = ET.SubElement(material_elem, "ionization_energy")
                    ionization_energy.text = str(material.ionization_energy)

            elif material.type == "boltzmann_electrons":
                # 玻尔兹曼电子材料
                if material.model:
                    model = ET.SubElement(material_elem, "model")
                    model.text = material.model

                if material.kTe0 is not None:
                    kTe0 = ET.SubElement(material_elem, "kTe0")
                    kTe0.text = str(material.kTe0)

            elif material.type == "solid":
                # 固体材料必需属性
                molwt = ET.SubElement(material_elem, "molwt")
                molwt_value = material.molwt if material.molwt is not None else self._get_default_molwt(material.type, material.name)
                if molwt_value == int(molwt_value):
                    molwt.text = str(int(molwt_value))
                else:
                    molwt.text = str(molwt_value)

                if material.density is not None:
                    density = ET.SubElement(material_elem, "density")
                    density.text = str(int(material.density) if material.density == int(material.density) else material.density)

        return self._prettify_xml(root)

    def _map_material_type_to_starfish(self, material_type: str) -> str:
        """将ezxml4starfish的材料类型映射到Starfish支持的类型"""
        # Starfish主要支持两种材料类型：kinetic 和 solid
        # kinetic: 用于气体、等离子体、离子、电子等动力学粒子
        # solid: 用于固体材料

        type_mapping = {
            # 动力学粒子类型 -> kinetic
            "GAS": "kinetic",
            "PLASMA-ELECTRON": "kinetic",
            "PLASMA-ION": "kinetic",
            "NEUTRAL": "kinetic",
            "ION": "kinetic",
            "ELECTRON": "kinetic",
            "kinetic": "kinetic",  # 已经是正确的类型

            # 固体材料类型 -> solid
            "SOLID": "solid",
            "solid": "solid",  # 已经是正确的类型

            # 液体材料暂时映射为solid（Starfish可能不直接支持液体）
            "LIQUID": "solid"
        }

        return type_mapping.get(material_type.upper(), "kinetic")  # 默认为kinetic

    def _get_default_diam(self, material_type: str, material_name: str) -> float:
        """为材料提供默认直径值"""
        # 基于材料类型和名称提供合理的默认直径
        material_name_upper = material_name.upper()
        material_type_upper = material_type.upper()

        # 电子的直径
        if "E-" in material_name_upper or "ELECTRON" in material_type_upper:
            return 1e-15  # 电子的经典半径量级

        # 离子的直径（基于原子类型）
        if "AR" in material_name_upper or "ARGON" in material_name_upper:
            return 4.17e-10  # 氩原子直径
        elif "HE" in material_name_upper or "HELIUM" in material_name_upper:
            return 2.58e-10  # 氦原子直径
        elif "N2" in material_name_upper or "NITROGEN" in material_name_upper:
            return 4.17e-10  # 氮分子直径
        elif "O2" in material_name_upper or "OXYGEN" in material_name_upper:
            return 4.07e-10  # 氧分子直径
        elif "H2" in material_name_upper or "HYDROGEN" in material_name_upper:
            return 2.89e-10  # 氢分子直径

        # 根据材料类型提供默认值
        if "ION" in material_type_upper or "PLASMA-ION" in material_type_upper:
            return 4.0e-10  # 一般离子直径
        elif "GAS" in material_type_upper or "NEUTRAL" in material_type_upper:
            return 4.0e-10  # 一般气体分子直径
        elif "ELECTRON" in material_type_upper or "PLASMA-ELECTRON" in material_type_upper:
            return 1e-15  # 电子直径

        # 默认值（原子量级）
        return 4.0e-10

    def _get_default_molwt(self, material_type: str, material_name: str) -> float:
        """为材料提供默认分子量值"""
        # 常见材料的分子量（原子质量单位 amu）
        common_materials = {
            # 惰性气体
            "AR": 39.948,    # 氩
            "AR+": 39.948,   # 氩离子
            "HE": 4.003,     # 氦
            "HE+": 4.003,    # 氦离子
            "NE": 20.180,    # 氖
            "NE+": 20.180,   # 氖离子
            "KR": 83.798,    # 氪
            "XE": 131.293,   # 氙

            # 常见气体
            "H2": 2.016,     # 氢气
            "N2": 28.014,    # 氮气
            "O2": 31.998,    # 氧气
            "CO2": 44.010,   # 二氧化碳
            "H2O": 18.015,   # 水蒸气

            # 离子和原子
            "H": 1.008,      # 氢原子
            "H+": 1.008,     # 氢离子
            "N": 14.007,     # 氮原子
            "N+": 14.007,    # 氮离子
            "O": 15.999,     # 氧原子
            "O+": 15.999,    # 氧离子

            # 电子
            "E-": 5.486e-4,  # 电子质量（amu）
            "ELECTRON": 5.486e-4,

            # 金属材料
            "CU": 63.546,    # 铜
            "AL": 26.982,    # 铝
            "FE": 55.845,    # 铁
            "SS": 55.845,    # 不锈钢（近似为铁）
            "W": 183.84,     # 钨
            "MO": 95.96,     # 钼
        }

        # 首先尝试根据材料名称匹配
        name_upper = material_name.upper()
        if name_upper in common_materials:
            return common_materials[name_upper]

        # 根据材料类型提供默认值
        type_defaults = {
            "GAS": 28.014,           # 默认为氮气
            "PLASMA-ELECTRON": 5.486e-4,  # 电子质量
            "PLASMA-ION": 39.948,    # 默认为氩离子
            "NEUTRAL": 39.948,       # 默认为氩原子
            "ION": 39.948,          # 默认为氩离子
            "ELECTRON": 5.486e-4,    # 电子质量
            "SOLID": 63.546,        # 默认为铜
            "LIQUID": 18.015,       # 默认为水
        }

        return type_defaults.get(material_type.upper(), 39.948)  # 最终默认为氩

    def _get_default_boundary_path(self, boundary: Boundary) -> str:
        """为边界生成默认路径"""
        # 如果有节点信息，根据节点生成路径
        if boundary.nodes and len(boundary.nodes) >= 2:
            # 使用SVG路径格式
            path_parts = []
            first_node = boundary.nodes[0]
            path_parts.append(f"M {first_node.x}, {first_node.y}")

            for node in boundary.nodes[1:]:
                path_parts.append(f"L {node.x} {node.y}")

            return " ".join(path_parts)

        # 根据边界名称和类型生成默认路径
        name_lower = boundary.name.lower()

        # 常见边界名称的默认路径
        if "left" in name_lower or "inlet" in name_lower:
            return "M 0, 0.2 L 0 0"  # 左边界
        elif "right" in name_lower or "outlet" in name_lower:
            return "M 1.0, 0 L 1.0 0.2"  # 右边界
        elif "top" in name_lower or "upper" in name_lower:
            return "M 0, 0.2 L 1.0 0.2"  # 上边界
        elif "bottom" in name_lower or "lower" in name_lower:
            return "M 0, 0 L 1.0 0"  # 下边界
        elif "wall" in name_lower:
            return "M 0, 0 L 1.0 0 L 1.0 0.2 L 0 0.2 Z"  # 封闭边界
        else:
            # 默认为简单的线段
            return "M 0, 0 L 1.0 0"

    def _generate_sources_xml(self, sources: List[Source], project: 'SimulationProject') -> str:
        """生成源文件 - 符合Starfish XML规范"""
        root = ET.Element("sources")

        for source in sources:
            # 基于Starfish v0.25的实际支持，所有源都使用 <boundary_source> 标签
            # 但根据原始类型使用不同的参数配置
            source_elem = ET.SubElement(root, "boundary_source")
            source_elem.set("name", source.name)

            if source.type in ["volume", "preload", "maxwellian"]:
                # 体积源转换为ambient边界源
                source_elem.set("type", "ambient")

                # 为体积源找到一个边界
                boundary_name = self._find_available_boundary_for_volume_source(source, project)
                boundary = ET.SubElement(source_elem, "boundary")
                boundary.text = boundary_name

                if source.material:
                    material = ET.SubElement(source_elem, "material")
                    material.text = source.material

                # 设置enforce为density（体积源通常控制密度）
                enforce = ET.SubElement(source_elem, "enforce")
                enforce.text = "density"

                # 添加drift_velocity（必需）
                drift_velocity = ET.SubElement(source_elem, "drift_velocity")
                drift_velocity.text = "0,0,0"  # 体积源无漂移

                if source.temperature is not None:
                    temperature = ET.SubElement(source_elem, "temperature")
                    temperature.text = str(source.temperature)

                # 将rate转换为density
                if source.rate is not None:
                    density = ET.SubElement(source_elem, "density")
                    # 简单的rate到density转换（这是一个近似）
                    density_value = source.rate / 1e15  # 简单的转换因子
                    density.text = str(max(density_value, 1e12))  # 最小密度值

            else:
                # 边界源 - 设置类型和基本参数
                source_elem.set("type", source.type)  # 使用原始类型

                if source.boundary:
                    boundary = ET.SubElement(source_elem, "boundary")
                    boundary.text = source.boundary

                if source.material:
                    material = ET.SubElement(source_elem, "material")
                    material.text = source.material

                # 根据边界源类型添加相应参数
                if source.type == "ambient":
                    # 环境源需要enforce、drift_velocity、temperature等
                    enforce = ET.SubElement(source_elem, "enforce")
                    if source.enforce:
                        enforce.text = source.enforce
                    elif source.density is not None:
                        enforce.text = "density"
                    else:
                        enforce.text = "pressure"

                    # 添加drift_velocity（必需）
                    drift_velocity = ET.SubElement(source_elem, "drift_velocity")
                    if source.drift_velocity:
                        drift_velocity.text = source.drift_velocity
                    elif source.v_drift is not None:
                        drift_velocity.text = f"{source.v_drift},0,0"
                    else:
                        drift_velocity.text = "0,0,0"

                    if source.temperature is not None:
                        temperature = ET.SubElement(source_elem, "temperature")
                        temperature.text = str(source.temperature)

                    # 添加密度或压力 - 确保只添加一个
                    if source.density is not None:
                        density = ET.SubElement(source_elem, "density")
                        density.text = str(source.density)
                    elif source.total_pressure is not None:
                        total_pressure = ET.SubElement(source_elem, "total_pressure")
                        total_pressure.text = str(source.total_pressure)
                    else:
                        # 提供默认压力
                        total_pressure = ET.SubElement(source_elem, "total_pressure")
                        total_pressure.text = "1000.0"

                elif source.type in ["uniform", "cosine"]:
                    # uniform和cosine源的参数
                    if source.mdot is not None:
                        mdot = ET.SubElement(source_elem, "mdot")
                        mdot.text = str(source.mdot)
                    else:
                        # 如果没有mdot，提供默认值
                        mdot = ET.SubElement(source_elem, "mdot")
                        mdot.text = "1e-12"  # 默认质量流率

                    if source.temperature is not None:
                        temperature = ET.SubElement(source_elem, "temperature")
                        temperature.text = str(source.temperature)

                    # uniform和cosine源需要v_drift参数
                    v_drift = ET.SubElement(source_elem, "v_drift")
                    if source.v_drift is not None:
                        v_drift.text = str(source.v_drift)
                    else:
                        # 提供默认漂移速度
                        v_drift.text = "0"

                elif source.type == "thermionic":
                    # 热离子发射源的参数
                    if source.temperature is not None:
                        temperature = ET.SubElement(source_elem, "temperature")
                        temperature.text = str(source.temperature)

                    # 热离子发射源可能需要其他特定参数





        return self._prettify_xml(root)

    def _find_available_boundary_for_volume_source(self, source: Source, project: 'SimulationProject') -> str:
        """为体积源找到一个可用的边界"""
        # 如果项目有边界，使用第一个边界
        if project.boundaries and len(project.boundaries) > 0:
            return project.boundaries[0].name

        # 如果没有边界，创建一个默认边界
        from app.models.simulation import Boundary
        default_boundary = Boundary(
            name="default_boundary",
            type="virtual",
            path="M 0,0 L 1,0"
        )
        project.boundaries.append(default_boundary)
        logger.info("Created default boundary for volume source")
        return "default_boundary"

    def _map_source_type_to_starfish(self, source_type: str) -> str:
        """将ezxml4starfish的源类型映射到Starfish支持的类型"""
        # 基于错误信息，Starfish可能只支持ambient类型的边界源
        # 所有边界源都映射为ambient类型
        type_mapping = {
            "uniform": "ambient",
            "cosine": "ambient",
            "ambient": "ambient",
            "thermionic": "ambient",
            "boundary": "ambient",
            "point": "ambient",
            "line": "ambient",
            "source": "ambient"
        }

        return type_mapping.get(source_type.lower(), "ambient")

    def _generate_interactions_xml(self, interactions: List[Interaction]) -> str:
        """生成相互作用文件 - 符合Starfish XML规范"""
        root = ET.Element("material_interactions")

        for interaction in interactions:
            if interaction.type == "surface_hit":
                # 表面碰撞
                interaction_elem = ET.SubElement(root, "surface_hit")

                # 处理source和target - 优先使用显式字段，否则从materials数组中提取
                source_material = interaction.source
                target_material = interaction.target

                if not source_material or not target_material:
                    if interaction.materials and len(interaction.materials) >= 2:
                        source_material = interaction.materials[0]
                        target_material = interaction.materials[1]

                if source_material:
                    interaction_elem.set("source", source_material)
                if target_material:
                    interaction_elem.set("target", target_material)

                if interaction.product:
                    product = ET.SubElement(interaction_elem, "product")
                    product.text = interaction.product

                if interaction.model:
                    model = ET.SubElement(interaction_elem, "model")
                    model.text = interaction.model

                if interaction.prob is not None:
                    prob = ET.SubElement(interaction_elem, "prob")
                    prob.text = str(interaction.prob)

                if interaction.c_accom is not None:
                    c_accom = ET.SubElement(interaction_elem, "c_accom")
                    c_accom.text = str(interaction.c_accom)

                if interaction.c_rest is not None:
                    c_rest = ET.SubElement(interaction_elem, "c_rest")
                    c_rest.text = str(interaction.c_rest)

            elif interaction.type == "dsmc":
                # DSMC碰撞
                interaction_elem = ET.SubElement(root, "dsmc")
                # model 属性是必需的，默认为 "elastic"
                model = interaction.model if interaction.model else "elastic"
                interaction_elem.set("model", model)

                if interaction.pair:
                    pair = ET.SubElement(interaction_elem, "pair")
                    pair.text = interaction.pair
                elif interaction.materials and len(interaction.materials) >= 2:
                    pair = ET.SubElement(interaction_elem, "pair")
                    pair.text = ",".join(interaction.materials[:2])

                # 处理sigma，确保使用Starfish支持的类型
                if interaction.sigma:
                    # 获取材料列表用于映射
                    materials_list = []
                    if interaction.pair:
                        materials_list = interaction.pair.split(",")
                    elif interaction.materials and len(interaction.materials) >= 2:
                        materials_list = interaction.materials[:2]

                    mapped_sigma = self._map_sigma_to_starfish(
                        interaction.sigma,
                        "dsmc",
                        materials_list
                    )
                    sigma = ET.SubElement(interaction_elem, "sigma")
                    sigma.text = mapped_sigma

                    # 如果映射到const sigma但原始不是const，且没有提供coeffs，提供默认值
                    if (mapped_sigma == "const" and
                        interaction.sigma.lower() != "const" and
                        not interaction.sigma_coeffs):
                        sigma_coeffs = ET.SubElement(interaction_elem, "sigma_coeffs")
                        sigma_coeffs.text = "1e-19"  # DSMC默认截面值
                    elif interaction.sigma_coeffs:
                        sigma_coeffs = ET.SubElement(interaction_elem, "sigma_coeffs")
                        sigma_coeffs.text = interaction.sigma_coeffs

                if interaction.frequency is not None:
                    frequency = ET.SubElement(interaction_elem, "frequency")
                    frequency.text = str(interaction.frequency)

                if interaction.sig_cr_max is not None:
                    sig_cr_max = ET.SubElement(interaction_elem, "sig_cr_max")
                    sig_cr_max.text = str(interaction.sig_cr_max)

            elif interaction.type == "mcc":
                # MCC碰撞
                interaction_elem = ET.SubElement(root, "mcc")
                if interaction.mcc_model:
                    interaction_elem.set("model", interaction.mcc_model)

                # 处理source和target - 优先使用显式字段，否则从materials数组中提取
                source_material = interaction.source
                target_material = interaction.target

                if not source_material or not target_material:
                    if interaction.materials and len(interaction.materials) >= 2:
                        source_material = interaction.materials[0]
                        target_material = interaction.materials[1]

                if source_material:
                    source = ET.SubElement(interaction_elem, "source")
                    source.text = source_material

                if target_material:
                    target = ET.SubElement(interaction_elem, "target")
                    target.text = target_material

                # 处理sigma，确保使用Starfish支持的类型
                if interaction.sigma:
                    # 映射sigma到Starfish支持的类型
                    materials_list = []
                    if source_material:
                        materials_list.append(source_material)
                    if target_material:
                        materials_list.append(target_material)

                    mapped_sigma = self._map_sigma_to_starfish(
                        interaction.sigma,
                        "mcc",
                        materials_list
                    )
                    sigma = ET.SubElement(interaction_elem, "sigma")
                    sigma.text = mapped_sigma

                    # 如果映射到const sigma但原始不是const，且没有提供coeffs，提供默认值
                    if (mapped_sigma == "const" and
                        interaction.sigma.lower() != "const" and
                        not interaction.sigma_coeffs):
                        sigma_coeffs = ET.SubElement(interaction_elem, "sigma_coeffs")
                        # 根据MCC模型类型提供合适的默认截面值
                        if interaction.mcc_model == "ionization":
                            sigma_coeffs.text = "1e-20"  # 电离截面默认值
                        elif interaction.mcc_model == "cex":
                            sigma_coeffs.text = "5e-19"  # 电荷交换截面默认值
                        else:
                            sigma_coeffs.text = "1e-19"  # 通用默认值
                    elif interaction.sigma_coeffs:
                        sigma_coeffs = ET.SubElement(interaction_elem, "sigma_coeffs")
                        sigma_coeffs.text = interaction.sigma_coeffs

                if interaction.max_target_temp is not None:
                    max_target_temp = ET.SubElement(interaction_elem, "max_target_temp")
                    max_target_temp.text = str(interaction.max_target_temp)

                # 注意：ionization_energy现在在材料定义中，不在MCC相互作用中

            elif interaction.type == "chemistry":
                # 化学反应
                interaction_elem = ET.SubElement(root, "chemistry")
                interaction_elem.set("name", interaction.name)

                if interaction.sources:
                    sources = ET.SubElement(interaction_elem, "sources")
                    sources.text = interaction.sources

                if interaction.products:
                    products = ET.SubElement(interaction_elem, "products")
                    products.text = interaction.products

                if interaction.rate_type or interaction.is_sigma is not None:
                    rate = ET.SubElement(interaction_elem, "rate")
                    if interaction.rate_type:
                        rate.set("type", interaction.rate_type)
                    if interaction.is_sigma is not None:
                        rate.set("is_sigma", str(interaction.is_sigma).lower())

                    if interaction.coeffs:
                        coeffs = ET.SubElement(rate, "coeffs")
                        coeffs.text = interaction.coeffs

                    if interaction.output_wrappers:
                        output_wrappers = ET.SubElement(rate, "output_wrappers")
                        output_wrappers.text = interaction.output_wrappers

                    # Starfish要求所有化学反应都有dep_var元素
                    if interaction.dep_var:
                        dep_var = ET.SubElement(rate, "dep_var")
                        # 对于const类型，尝试使用Starfish支持的变量名
                        if interaction.rate_type == "const":
                            # 尝试使用电子密度变量名
                            dep_var.text = "ne"  # 电子密度
                        else:
                            dep_var.text = interaction.dep_var
                    else:
                        # 如果没有指定dep_var，提供默认值
                        dep_var = ET.SubElement(rate, "dep_var")
                        dep_var.text = "ne"  # 默认使用电子密度

            elif interaction.type == "sputtering":
                # 溅射
                interaction_elem = ET.SubElement(root, "sputtering")
                # 溅射参数可以根据需要添加
            else:
                # 其他类型的相互作用 - 映射到Starfish支持的类型
                logger.warning(f"Unknown interaction type '{interaction.type}', mapping to supported Starfish format")

                # 根据相互作用类型和名称，映射到Starfish支持的格式
                if (interaction.source and interaction.target) or any(keyword in interaction.name.lower() for keyword in ['surface', 'impact', 'wall', 'hit']):
                    # 表面撞击相互作用 - 使用surface_hit格式
                    interaction_elem = ET.SubElement(root, "surface_hit")

                    # 设置源和目标材料
                    if interaction.source:
                        interaction_elem.set("source", interaction.source)
                    elif interaction.materials and len(interaction.materials) >= 1:
                        interaction_elem.set("source", interaction.materials[0])

                    if interaction.target:
                        interaction_elem.set("target", interaction.target)
                    elif interaction.materials and len(interaction.materials) >= 2:
                        interaction_elem.set("target", interaction.materials[1])

                    # 添加产物
                    if interaction.product:
                        product = ET.SubElement(interaction_elem, "product")
                        product.text = interaction.product
                    elif interaction.materials and len(interaction.materials) >= 1:
                        product = ET.SubElement(interaction_elem, "product")
                        product.text = interaction.materials[0]  # 默认产物与源相同

                    # 添加模型
                    model = ET.SubElement(interaction_elem, "model")
                    model.text = interaction.model or "diffuse"  # 默认为漫反射

                    # 添加概率
                    prob = ET.SubElement(interaction_elem, "prob")
                    prob.text = str(interaction.prob if interaction.prob is not None else 1.0)

                else:
                    # 默认作为DSMC处理 - 这是Starfish支持的主要相互作用类型
                    logger.info(f"Mapping interaction '{interaction.name}' to DSMC format")
                    interaction_elem = ET.SubElement(root, "dsmc")

                    # 设置模型 - 只支持Starfish认可的模型
                    model_name = interaction.model or interaction.type.lower()
                    # Starfish支持的DSMC模型：elastic, inelastic
                    if model_name not in ["elastic", "inelastic"]:
                        # 将不支持的模型映射到支持的模型
                        if model_name in ["charge_exchange", "ionization", "excitation"]:
                            model_name = "inelastic"  # 非弹性过程
                        else:
                            model_name = "elastic"  # 默认为弹性碰撞
                    interaction_elem.set("model", model_name)

                    # 添加材料对
                    if interaction.materials and len(interaction.materials) >= 2:
                        pair = ET.SubElement(interaction_elem, "pair")
                        pair.text = ",".join(interaction.materials[:2])  # 只取前两个材料

                    # 添加碰撞截面
                    sigma = ET.SubElement(interaction_elem, "sigma")
                    sigma.text = interaction.sigma or "Bird463"  # 默认使用Bird463模型

                    # 添加频率
                    frequency = ET.SubElement(interaction_elem, "frequency")
                    frequency.text = str(interaction.frequency if interaction.frequency is not None else 1)

        return self._prettify_xml(root)

    def _map_interaction_model_to_starfish(self, model_name: str, materials: List[str], sigma: str = None) -> str:
        """
        将相互作用模型映射到Starfish支持的类型

        Args:
            model_name: 原始模型名称
            materials: 参与相互作用的材料列表
            sigma: 碰撞截面模型

        Returns:
            str: Starfish支持的模型名称
        """
        model_lower = model_name.lower()

        # 直接支持的模型
        if model_lower in ["elastic", "inelastic"]:
            return model_lower

        # 根据材料对和模型名称进行智能映射
        if materials and len(materials) >= 2:
            material_pair = [m.lower() for m in materials]

            # 电离反应：e- + 中性原子 -> e- + e- + 离子
            # 注意：Starfish DSMC只支持elastic模型，所以电离反应映射为elastic
            if (model_lower in ["ionization", "impact_ionization", "electron_impact"] or
                ("e-" in material_pair and any("ar" in m and "+" not in m for m in material_pair))):
                return "elastic"  # Starfish不支持真正的电离，映射为elastic

            # 复合反应：e- + 离子 -> 中性原子
            # 注意：Starfish DSMC只支持elastic模型，所以复合反应映射为elastic
            elif (model_lower in ["recombination", "electron_ion_recombination"] or
                  ("e-" in material_pair and any("+" in m for m in material_pair))):
                return "elastic"  # Starfish不支持真正的复合，映射为elastic

            # 电荷交换：离子 + 中性原子 -> 中性原子 + 离子
            elif model_lower in ["charge_exchange", "cx"]:
                return "elastic"

            # 激发反应
            elif model_lower in ["excitation", "electronic_excitation"]:
                return "inelastic"  # 激发是非弹性过程

        # 默认映射为弹性碰撞
        return "elastic"

    def _has_ionization_reactions(self, project: 'SimulationProject') -> bool:
        """检测项目是否包含电离反应"""
        if not hasattr(project, 'interactions') or not project.interactions:
            return False

        for interaction in project.interactions:
            # 检查相互作用类型或模型是否为电离相关
            interaction_type = getattr(interaction, 'type', '').lower()
            interaction_model = getattr(interaction, 'model', '').lower()

            if (interaction_type in ['ionization', 'impact_ionization', 'electron_impact'] or
                interaction_model in ['ionization', 'impact_ionization', 'electron_impact']):
                return True

            # 检查材料对是否为典型的电离反应 (e- + 中性原子)
            if hasattr(interaction, 'materials') and interaction.materials:
                materials = [m.lower() for m in interaction.materials]
                if 'e-' in materials and any('ar' in m and '+' not in m for m in materials):
                    return True

        return False

    def _add_reaction_products(self, interaction_elem: ET.Element, interaction, reaction_type: str):
        """
        为电离和复合反应添加产物信息

        Args:
            interaction_elem: XML元素
            interaction: 相互作用对象
            reaction_type: 反应类型 ("ionization" 或 "recombination")
        """
        if reaction_type == "ionization":
            # 电离反应：e- + Ar -> e- + e- + Ar+
            # 添加产物信息
            products_elem = ET.SubElement(interaction_elem, "products")

            # 从反应物推断产物
            if hasattr(interaction, 'materials') and interaction.materials:
                materials = interaction.materials
                # 寻找中性原子（如Ar）
                neutral_atom = None
                for material in materials:
                    if "+" not in material and material.lower() != "e-":
                        neutral_atom = material
                        break

                if neutral_atom:
                    # 电离产物：2个电子 + 1个离子
                    product_elem1 = ET.SubElement(products_elem, "product")
                    product_elem1.set("species", "e-")
                    product_elem1.set("count", "2")

                    product_elem2 = ET.SubElement(products_elem, "product")
                    product_elem2.set("species", f"{neutral_atom}+")
                    product_elem2.set("count", "1")

        elif reaction_type == "recombination":
            # 复合反应：e- + Ar+ -> Ar
            # 添加产物信息
            products_elem = ET.SubElement(interaction_elem, "products")

            # 从反应物推断产物
            if hasattr(interaction, 'materials') and interaction.materials:
                materials = interaction.materials
                # 寻找离子（如Ar+）
                ion = None
                for material in materials:
                    if "+" in material:
                        ion = material
                        break

                if ion:
                    # 复合产物：中性原子
                    neutral_atom = ion.replace("+", "")
                    product_elem = ET.SubElement(products_elem, "product")
                    product_elem.set("species", neutral_atom)
                    product_elem.set("count", "1")

    def _map_sigma_to_starfish(self, sigma: str, model: str, materials: List[str]) -> str:
        """
        将碰撞截面模型映射到Starfish支持的类型

        Args:
            sigma: 原始sigma模型
            model: 相互作用模型类型
            materials: 参与相互作用的材料

        Returns:
            str: Starfish支持的sigma模型
        """
        sigma_lower = sigma.lower()

        # Starfish实际支持的sigma模型（基于错误信息和实际测试）
        # 注意：tabulated需要额外的数据文件，暂时不支持
        starfish_supported_sigma = [
            "const",     # 常数截面
            "bird463"    # Bird463模型（主要支持的模型）
        ]

        # 检查是否直接支持
        for supported in starfish_supported_sigma:
            if supported in sigma_lower:
                if supported == "const":
                    return "const"
                else:
                    return "Bird463"  # 统一返回标准格式

        # 将不支持的模型映射到支持的模型
        sigma_mapping = {
            "vhs": "Bird463",              # VHS映射为Bird463
            "vss": "Bird463",              # VSS映射为Bird463
            "hs": "Bird463",               # 硬球模型映射为Bird463
            "constant": "const",           # 常数截面
            "phelps": "const",             # Phelps模型映射为常数
            "phelps_ionization": "const",  # 电离用常数
            "landau": "const",             # Landau映射为常数
            "landau_recombination": "const", # 复合用常数
            "coulomb": "const",            # Coulomb映射为常数
            "tabulated": "const",          # tabulated映射为常数（避免错误）
        }

        # 尝试映射
        if sigma_lower in sigma_mapping:
            mapped_sigma = sigma_mapping[sigma_lower]
            return mapped_sigma

        # 根据材料对和模型类型进行智能映射
        if materials and len(materials) >= 2:
            material_pair = [m.lower() for m in materials]

            # 对于MCC碰撞，优先使用常数截面
            if model and model.lower() == "mcc":
                return "const"

            # 对于包含电子的碰撞，使用常数截面
            if "e-" in material_pair:
                return "const"

            # 其他情况使用Bird463模型
            return "Bird463"

        # 默认使用常数截面（最安全的选择）
        return "const"

    def _validate_and_fix_material_references(self, project: SimulationProject) -> None:
        """验证和修复材料引用"""
        # 收集所有已定义的材料名称
        defined_materials = {material.name for material in project.materials}
        logger.info(f"Defined materials: {sorted(defined_materials)}")

        # 收集所有引用的材料名称
        referenced_materials = set()

        # 检查边界中的材料引用
        for boundary in project.boundaries:
            if boundary.material:
                referenced_materials.add(boundary.material)
                if boundary.material not in defined_materials:
                    logger.warning(f"Boundary '{boundary.name}' references undefined material '{boundary.material}'")
                    # 修复：使用默认材料或创建缺失的材料
                    default_material = self._create_default_material(boundary.material)
                    project.materials.append(default_material)
                    defined_materials.add(default_material.name)
                    logger.info(f"Created default material '{default_material.name}' for boundary '{boundary.name}'")

        # 检查源中的材料引用
        for source in project.sources:
            if source.material:
                referenced_materials.add(source.material)
                if source.material not in defined_materials:
                    logger.warning(f"Source '{source.name}' references undefined material '{source.material}'")
                    # 修复：使用默认材料或创建缺失的材料
                    default_material = self._create_default_material(source.material)
                    project.materials.append(default_material)
                    defined_materials.add(default_material.name)
                    logger.info(f"Created default material '{default_material.name}' for source '{source.name}'")

        # 检查相互作用中的材料引用
        for interaction in project.interactions:
            # 检查materials列表
            for material_name in interaction.materials:
                referenced_materials.add(material_name)
                if material_name not in defined_materials:
                    logger.warning(f"Interaction '{interaction.name}' references undefined material '{material_name}'")
                    # 修复：使用默认材料或创建缺失的材料
                    default_material = self._create_default_material(material_name)
                    project.materials.append(default_material)
                    defined_materials.add(default_material.name)
                    logger.info(f"Created default material '{default_material.name}' for interaction '{interaction.name}'")

            # 检查单独的材料字段
            material_fields = [interaction.source, interaction.target, interaction.product]
            for material_name in material_fields:
                if material_name:
                    referenced_materials.add(material_name)
                    if material_name not in defined_materials:
                        logger.warning(f"Interaction '{interaction.name}' references undefined material '{material_name}'")
                        # 修复：使用默认材料或创建缺失的材料
                        default_material = self._create_default_material(material_name)
                        project.materials.append(default_material)
                        defined_materials.add(default_material.name)
                        logger.info(f"Created default material '{default_material.name}' for interaction '{interaction.name}'")

            # 检查化学反应中的材料
            if interaction.sources:
                for material_name in interaction.sources.split(','):
                    material_name = material_name.strip()
                    if material_name:
                        referenced_materials.add(material_name)
                        if material_name not in defined_materials:
                            logger.warning(f"Interaction '{interaction.name}' references undefined material '{material_name}' in sources")
                            default_material = self._create_default_material(material_name)
                            project.materials.append(default_material)
                            defined_materials.add(default_material.name)
                            logger.info(f"Created default material '{default_material.name}' for interaction '{interaction.name}'")

            if interaction.products:
                for material_name in interaction.products.split(','):
                    material_name = material_name.strip()
                    if material_name:
                        referenced_materials.add(material_name)
                        if material_name not in defined_materials:
                            logger.warning(f"Interaction '{interaction.name}' references undefined material '{material_name}' in products")
                            default_material = self._create_default_material(material_name)
                            project.materials.append(default_material)
                            defined_materials.add(default_material.name)
                            logger.info(f"Created default material '{default_material.name}' for interaction '{interaction.name}'")

        logger.info(f"Referenced materials: {sorted(referenced_materials)}")
        logger.info(f"Material reference validation completed")

    def _create_default_material(self, material_name: str) -> Material:
        """为缺失的材料创建默认定义"""
        from app.models.simulation import Material

        # 根据材料名称推断类型和属性
        name_lower = material_name.lower()

        # 推断材料类型
        if any(keyword in name_lower for keyword in ['ion', '+', 'plasma']):
            material_type = "kinetic"
            charge = 1.0
        elif any(keyword in name_lower for keyword in ['electron', 'e-', 'e_']):
            material_type = "kinetic"  # kinetic电子用于MCC碰撞
            charge = -1.0
        elif any(keyword in name_lower for keyword in ['solid', 'wall', 'metal', 'cu', 'al', 'fe', 'ss']):
            material_type = "solid"
            charge = 0.0
        else:
            material_type = "kinetic"  # 默认为kinetic
            charge = 0.0

        # 为kinetic电子提供完整的属性
        if 'e' in name_lower and 'kinetic' in name_lower:
            default_material = Material(
                name=material_name,
                type=material_type,
                charge=charge,
                molwt=5.486e-4,  # 电子质量（原子质量单位）
                spwt=1e11,
                ref_temp=273,
                visc_temp_index=0.5,
                vss_alpha=1.00,
                diam=1e-15  # 电子有效直径
            )
        else:
            # 创建默认材料
            default_material = Material(
                name=material_name,
                type=material_type,
                charge=charge
                # molwt和spwt等会在XML生成时自动添加默认值
            )

        # 如果是固体材料，添加密度
        if material_type == "SOLID":
            default_material.density = 8000.0  # 默认密度

        logger.info(f"Created default material: {material_name} (type: {material_type}, charge: {charge})")
        return default_material

    def _process_ionization_energies(self, project: SimulationProject) -> None:
        """
        处理电离能：从MCC相互作用中提取电离能并添加到目标材料定义中
        """
        # 收集所有MCC电离相互作用的电离能信息
        ionization_energies = {}

        for interaction in project.interactions:
            if (interaction.type == "mcc" and
                interaction.mcc_model == "ionization" and
                interaction.ionization_energy is not None):

                # 获取target材料 - 优先使用显式target字段，否则从materials数组中提取
                target_material = interaction.target
                if not target_material and interaction.materials and len(interaction.materials) >= 2:
                    target_material = interaction.materials[1]  # 第二个材料通常是目标

                if target_material:
                    ionization_energy = interaction.ionization_energy

                    # 如果同一材料有多个电离能，使用第一个
                    if target_material not in ionization_energies:
                        ionization_energies[target_material] = ionization_energy
                        logger.info(f"Found ionization energy {ionization_energy} eV for material '{target_material}'")

        # 将电离能添加到相应的材料定义中
        for material in project.materials:
            if material.name in ionization_energies:
                # 设置电离能（如果尚未设置或为None）
                if material.ionization_energy is None:
                    material.ionization_energy = ionization_energies[material.name]
                    logger.info(f"Set ionization energy {material.ionization_energy} eV for material '{material.name}'")

    def _map_solver_type_to_starfish(self, solver_type: str) -> str:
        """将ezxml4starfish的求解器类型映射到Starfish支持的类型"""
        # Starfish支持的求解器类型
        type_mapping = {
            # 泊松求解器相关
            "POISSON": "poisson",
            "SOR": "poisson",  # SOR是求解泊松方程的方法，映射为poisson
            "GS": "poisson",   # Gauss-Seidel也是求解泊松方程的方法
            "JACOBI": "poisson",
            "CG": "poisson",   # 共轭梯度法
            "MULTIGRID": "poisson",

            # 恒定电场求解器
            "CONSTANT-EF": "constant-ef",
            "CONSTANT_EF": "constant-ef",
            "CONSTANT": "constant-ef",

            # PIC求解器（通常不需要显式求解器配置）
            "PIC": "poisson",  # PIC通常需要泊松求解器求解电势
            "DSMC": "dsmc",    # 虽然通常不生成solver元素，但保留映射

            # 已经是正确的类型
            "poisson": "poisson",
            "constant-ef": "constant-ef"
        }

        mapped_type = type_mapping.get(solver_type.upper(), "poisson")  # 默认为poisson
        logger.info(f"Mapped solver type '{solver_type}' to '{mapped_type}'")
        return mapped_type

    def _prettify_xml(self, elem: ET.Element) -> str:
        """格式化XML输出"""
        rough_string = ET.tostring(elem, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        pretty_xml = reparsed.toprettyxml(indent="  ")

        # 移除空行和XML声明
        lines = [line for line in pretty_xml.split('\n') if line.strip()]
        if lines and lines[0].startswith('<?xml'):
            lines = lines[1:]  # 移除XML声明行

        return '\n'.join(lines)
