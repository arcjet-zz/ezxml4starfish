"""
XML生成服务
将JSON结构生成为Starfish XML文件
"""

from typing import Dict, List, Any
import xml.etree.ElementTree as ET
from xml.dom import minidom
import logging

from app.models.simulation import SimulationProject, Boundary, Material, Source, Interaction

logger = logging.getLogger(__name__)

class XMLGeneratorService:
    """XML生成服务类"""

    def generate_xml_files(self, project: SimulationProject) -> Dict[str, str]:
        """
        生成所有XML文件

        Args:
            project: 项目对象

        Returns:
            Dict[str, str]: 文件名到XML内容的映射
        """
        logger.info("Starting XML file generation")
        xml_files = {}

        # 生成主配置文件
        xml_files["starfish.xml"] = self._generate_starfish_xml(project)
        logger.info("Generated starfish.xml")

        # 生成计算域文件
        xml_files["domain.xml"] = self._generate_domain_xml(project)
        logger.info("Generated domain.xml")

        # 生成边界文件
        if project.boundaries:
            xml_files["boundaries.xml"] = self._generate_boundaries_xml(project.boundaries)
            logger.info("Generated boundaries.xml")

        # 生成材料文件
        if project.materials:
            xml_files["materials.xml"] = self._generate_materials_xml(project.materials)
            logger.info("Generated materials.xml")

        # 生成源文件
        if project.sources:
            xml_files["sources.xml"] = self._generate_sources_xml(project.sources)
            logger.info("Generated sources.xml")

        # 生成相互作用文件
        if project.interactions:
            xml_files["interactions.xml"] = self._generate_interactions_xml(project.interactions)
            logger.info("Generated interactions.xml")

        logger.info(f"Generated {len(xml_files)} XML files")
        return xml_files
    
    def _generate_starfish_xml(self, project: SimulationProject) -> str:
        """生成主配置文件"""
        root = ET.Element("simulation")

        # 添加注释
        note = ET.SubElement(root, "note")
        note.text = "Generated by Starfish-ezxml"

        # 添加日志配置
        log = ET.SubElement(root, "log")
        log.set("level", "Log")

        # 添加加载指令
        load_domain = ET.SubElement(root, "load")
        load_domain.text = "domain.xml"

        if project.boundaries:
            load_boundaries = ET.SubElement(root, "load")
            load_boundaries.text = "boundaries.xml"

        if project.materials:
            load_materials = ET.SubElement(root, "load")
            load_materials.text = "materials.xml"

        if project.sources:
            load_sources = ET.SubElement(root, "load")
            load_sources.text = "sources.xml"

        if project.interactions:
            load_interactions = ET.SubElement(root, "load")
            load_interactions.text = "interactions.xml"

        # 添加求解器配置
        solver = ET.SubElement(root, "solver")
        solver.set("type", project.settings.solver_type.lower())

        # 添加求解器参数
        if hasattr(project.settings, 'method') and project.settings.method:
            method = ET.SubElement(solver, "method")
            method.text = project.settings.method

        if project.settings.n0 is not None:
            n0 = ET.SubElement(solver, "n0")
            n0.text = str(project.settings.n0)

        if project.settings.Te0 is not None:
            te0 = ET.SubElement(solver, "Te0")
            te0.text = str(project.settings.Te0)

        if project.settings.phi0 is not None:
            phi0 = ET.SubElement(solver, "phi0")
            phi0.text = str(project.settings.phi0)

        if project.settings.max_it is not None:
            max_it = ET.SubElement(solver, "max_it")
            max_it.text = str(project.settings.max_it)

        if project.settings.tolerance is not None:
            tol = ET.SubElement(solver, "tol")
            tol.text = str(project.settings.tolerance)

        # 添加时间配置
        time = ET.SubElement(root, "time")
        num_it = ET.SubElement(time, "num_it")
        num_it.text = str(project.settings.iterations)
        dt = ET.SubElement(time, "dt")
        dt.text = str(project.settings.time_step)

        if project.settings.steady_state is not None:
            steady_state = ET.SubElement(time, "steady_state")
            steady_state.text = str(project.settings.steady_state)

        # 添加运行指令
        starfish = ET.SubElement(root, "starfish")

        if project.settings.randomize is not None:
            starfish.set("randomize", str(project.settings.randomize).lower())

        if project.settings.max_cores is not None:
            starfish.set("max_cores", str(project.settings.max_cores))

        return self._prettify_xml(root)

    def _generate_domain_xml(self, project: SimulationProject) -> str:
        """生成计算域文件"""
        root = ET.Element("domain")
        root.set("type", project.domain.type)

        # 添加网格配置
        mesh = ET.SubElement(root, "mesh")
        mesh.set("type", project.domain.mesh_type)
        mesh.set("name", project.domain.mesh_name)

        # 添加原点
        origin = ET.SubElement(mesh, "origin")
        origin.text = ",".join(map(str, project.domain.origin))

        # 添加间距
        spacing = ET.SubElement(mesh, "spacing")
        spacing.text = ",".join(map(str, project.domain.spacing))

        # 添加节点数
        nodes = ET.SubElement(mesh, "nodes")
        nodes.text = ",".join(map(str, project.domain.nodes))

        return self._prettify_xml(root)
    
    def _generate_boundaries_xml(self, boundaries: List[Boundary]) -> str:
        """生成边界文件"""
        root = ET.Element("boundaries")

        for boundary in boundaries:
            boundary_elem = ET.SubElement(root, "boundary")
            boundary_elem.set("name", boundary.name)
            boundary_elem.set("type", boundary.type)
            boundary_elem.set("potential", str(boundary.potential))

            # 添加节点
            if boundary.nodes:
                nodes_elem = ET.SubElement(boundary_elem, "nodes")
                for node in boundary.nodes:
                    node_elem = ET.SubElement(nodes_elem, "node")
                    node_elem.set("x", str(node.x))
                    node_elem.set("y", str(node.y))

        return self._prettify_xml(root)

    def _generate_materials_xml(self, materials: List[Material]) -> str:
        """生成材料文件"""
        root = ET.Element("materials")

        for material in materials:
            material_elem = ET.SubElement(root, "material")
            material_elem.set("name", material.name)
            material_elem.set("type", material.type.lower())

            # 添加基本属性
            if material.molwt is not None:
                molwt = ET.SubElement(material_elem, "molwt")
                molwt.text = str(material.molwt)

            if material.charge != 0:
                charge = ET.SubElement(material_elem, "charge")
                charge.text = str(material.charge)

            if material.spwt is not None:
                spwt = ET.SubElement(material_elem, "spwt")
                spwt.text = str(material.spwt)

            if material.ref_temp is not None:
                ref_temp = ET.SubElement(material_elem, "ref_temp")
                ref_temp.text = str(material.ref_temp)

            if material.visc_temp_index is not None:
                visc_temp_index = ET.SubElement(material_elem, "visc_temp_index")
                visc_temp_index.text = str(material.visc_temp_index)

            if material.vss_alpha is not None:
                vss_alpha = ET.SubElement(material_elem, "vss_alpha")
                vss_alpha.text = str(material.vss_alpha)

            if material.diam is not None:
                diam = ET.SubElement(material_elem, "diam")
                diam.text = str(material.diam)

        return self._prettify_xml(root)

    def _generate_sources_xml(self, sources: List[Source]) -> str:
        """生成源文件"""
        root = ET.Element("sources")

        for source in sources:
            # 根据源类型选择元素名称
            if hasattr(source, 'boundary') and source.boundary:
                source_elem = ET.SubElement(root, "boundary_source")
                source_elem.set("name", source.name)
                source_elem.set("type", source.type)

                # 添加边界关联
                boundary = ET.SubElement(source_elem, "boundary")
                boundary.text = source.boundary

                # 添加材料关联
                if source.material:
                    material = ET.SubElement(source_elem, "material")
                    material.text = source.material

                # 添加质量流率
                if hasattr(source, 'mdot') and source.mdot is not None:
                    mdot = ET.SubElement(source_elem, "mdot")
                    mdot.text = str(source.mdot)

                # 添加漂移速度
                if hasattr(source, 'v_drift') and source.v_drift is not None:
                    v_drift = ET.SubElement(source_elem, "v_drift")
                    v_drift.text = str(source.v_drift)

                # 添加温度
                if source.temperature is not None:
                    temperature = ET.SubElement(source_elem, "temperature")
                    temperature.text = str(source.temperature)
            else:
                source_elem = ET.SubElement(root, "source")
                source_elem.set("name", source.name)
                source_elem.set("type", source.type)

                # 添加材料关联
                if source.material:
                    material = ET.SubElement(source_elem, "material")
                    material.text = source.material

                # 添加生成率
                if source.rate is not None:
                    rate = ET.SubElement(source_elem, "rate")
                    rate.text = str(source.rate)

                # 添加温度
                if source.temperature is not None:
                    temperature = ET.SubElement(source_elem, "temperature")
                    temperature.text = str(source.temperature)

        return self._prettify_xml(root)

    def _generate_interactions_xml(self, interactions: List[Interaction]) -> str:
        """生成相互作用文件"""
        root = ET.Element("interactions")

        for interaction in interactions:
            interaction_elem = ET.SubElement(root, "interaction")
            interaction_elem.set("name", interaction.name)
            interaction_elem.set("type", interaction.type)

            # 添加参与的材料
            if interaction.materials:
                materials = ET.SubElement(interaction_elem, "materials")
                materials.text = ",".join(interaction.materials)

        return self._prettify_xml(root)

    def _prettify_xml(self, elem: ET.Element) -> str:
        """格式化XML输出"""
        rough_string = ET.tostring(elem, encoding='unicode')
        reparsed = minidom.parseString(rough_string)
        pretty_xml = reparsed.toprettyxml(indent="  ")

        # 移除空行和XML声明
        lines = [line for line in pretty_xml.split('\n') if line.strip()]
        if lines and lines[0].startswith('<?xml'):
            lines = lines[1:]  # 移除XML声明行

        return '\n'.join(lines)
